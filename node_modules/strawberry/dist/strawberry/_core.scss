/// <reference path="./_common.scss" />
/// <reference path="./core/_color.scss" />
/// <reference path="./core/_component.scss" />
/// <reference path="./core/_font.scss" />
/// <reference path="./core/_media.scss" />


// ==================
// Group dependencies
// ==================

/// <reference path="./common/_validation.scss" />
/// <reference path="./common/_string.scss" />
/// <reference path="./common/_list.scss" />
/// <reference path="./common/_scope.scss" />


// =============
// Group content
// =============

// Groups
// ======

// == Validation group ==

/// <reference path="./validation/_argument-type-error.function.scss" />
/// <reference path="./validation/_argument-value-error.function.scss" />
/// <reference path="./validation/_no-error.function.scss" />
/// <reference path="./validation/_validate-type.function.scss" />
/// <reference path="./validation/_validate.function.scss" />


// =============
// Group content
// =============

// Variables
// =========

/// The list of every type accepted by the type validation functions.
/// @access private
/// @group common
/// @type List
$_valid-types: 
'bool'
'color'
'list'
'list<bool>'
'list<color>'
'list<number>'
'list<string>'
'map'
'map<bool, bool>'
'map<bool, color>'
'map<bool, number>'
'map<bool, string>'
'map<color, bool>'
'map<color, color>'
'map<color, number>'
'map<color, string>'
'map<number, bool>'
'map<number, color>'
'map<number, number>'
'map<number, string>'
'map<string, bool>'
'map<string, color>'
'map<string, number>'
'map<string, string>'
'number'
'string'
!global;

// Functions
// =========

/// Returns a argument type error message.
/// @access public
/// @group common
/// @param {String} $argumentName - The name of the invalid argument
/// @param {String} $functionName - The name of the called function
/// @param {String} $expectedType ['%type%'] - The expected argument type
/// @return {String} - The error message
/// @example 
///   validate-type($foo, 'string', argument-type-error('$foo', 'bar()')
@function argument-type-error(
  $argumentName,
  $functionName,
  $expectedType: '%type%'
  ) {
  $this: 'argument-type-error()';
  @if no-error(
    validate-type($argumentName, 'string', 'argument `$argumentName` of `#{$this}` must be a string'),
    validate-type($functionName, 'string', 'argument `$functionName` of `#{$this}` must be a string'),
    validate-type($expectedType, 'string', 'argument `$expectedType` of `#{$this}` must be a string')
    ) {

  
    @return 'argument `#{$argumentName}` of `#{$functionName}` must be a #{$expectedType}';

  }
}
/// Returns a argument value error message.
/// @access public
/// @group common
/// @param {String} $argumentName - The name of the invalid argument
/// @param {String} $functionName - The name of the called function
/// @param {*} $invalidValue - The invalid values of the argument
/// @return {String} - The error message
/// @example 
///   validate-type(5, 'number', argument-type-error('$myArgs', 'myFn()', 0)
@function argument-value-error(
  $argumentName,
  $functionName,
  $invalidValues
  ) {
  $this: 'argument-value-error()';
  @if no-error(
    validate-type($argumentName, 'string', 'argument `$argumentName` of `#{$this}` must be a string'),
    validate-type($functionName, 'string', 'argument `$functionName` of `#{$this}` must be a string')
    ) {


    @return 'argument `#{$argumentName}` of `#{$functionName}` can\'t be `#{$invalidValues}`';

  }
}
/// A function block to put some validations
/// @access public
/// @group common
/// @return {Null}
/// @example 
///   @if no-error(
///     validate-type($foo, 'number', argument-type-error('$foo', 'bar()')),
///     validate($foo != 0, argument-value-error('$foo', 'bar()', 0))
///     ) { ... }
@function no-error(
  $validations...
  ) {


  @return true;

}
/// Throws an error if the given expression is false.
/// @access public
/// @group common
/// @param {Boolean} $expression - The expression to validate
/// @param {String} $errorMessage - The error message to display in case of false expression,
/// @param {Boolean} $continue [false] - If true, no error will be threw
/// @return {Boolean}
@function validate(
  $expression,
  $errorMessage,
  $continue: false
  ) {
  $this: 'validate()';
  // If `$expression` is not a boolean
  @if type-of($expression) != 'bool' {
    // throws an error.
    @error argument-type-error('$expression', $this, 'bool');
  }
  // If `$errorMessage` is not a string
  @if type-of($errorMessage) != 'string' {
    // throws an error.
    @error argument-type-error('$errorMessage', $this, 'string');;
  }
  // If `$continue` is not a boolean
  @if type-of($continue) != 'bool' {
    // throws an error.
    @error argument-type-error('$continue', $this, 'bool');;
  }


  @if $expression == false and $continue == false {
    @error $errorMessage;
  }

  @return $expression;
  
}
/// Throws an error if the given value is not equal to the expected type.
/// @access public
/// @group common
/// @param {*} $value - The value
/// @param {String} $expectedType - The expected type
/// @param {String} $errorMessage - The error message to display in case of error
/// @param {Boolean} $continue [false] - If true, no error will be threw
/// @return {Boolean}
/// @example 
///   validate-type($value, 'string', '$value must be a %type%')
@function validate-type(
  $value,
  $expectedType,
  $errorMessage,
  $continue: false
  ) {
  $this: 'validate-type()';
  // If `$expectedType` is not in the valid type list
  @if index($_valid-types, $expectedType) == null {
    // throws an error.
    @error argument-type-error('$value', $this, 'string contained in the following list: `#{$_valid-types}`');
  }
  // If `$errorMessage` is not a string
  @if type-of($errorMessage) != 'string' {
    // throws an error.
    @error argument-type-error('$errorMessage', $this, 'string');
  }
  // If `$continue` is not a boolean
  @if type-of($continue) != 'bool' {
    // throws an error.
    @error argument-type-error('$continue', $this, 'bool');;
  }
  
 
  $result: null;

  @if str-index($errorMessage, '%type%') {
    // Replaces any occurence of `%type%` in the error message with the expected type.
    $errorMessage: str-replace($errorMessage, '%type%', $expectedType);  
  }

  // If the type is a generic (ex: list<string>).
  @if str-index($expectedType, '<') != null and str-index($expectedType, '>') == str-length($expectedType) {
    // If $value is a list or a map.
    $values: $value;

    // Gets the generic type (type inside the carrets).
    $genericType: str-slice($expectedType, str-index($expectedType, '<') + 1, str-length($expectedType) - 1);

    // If $value is a list and the expected type is generic list
    @if type-of($value) == 'list' and str-index($expectedType, 'list') != null {
       
      // loops through the list
      @each $item in $values {
        // to validate type of each item.
        $result: validate(type-of($item) == $genericType, $errorMessage, $continue);
      }
    }

    // If $value is a map and the expected type is generic map
    @if type-of($value) == 'map' and str-index($expectedType, 'map') != null {
       
      $genericKeyType: str-slice($genericType, 1, str-index($genericType, ',') - 1);
      $genericValueType: str-slice($genericType, str-index($genericType, ',') + 2, str-length($genericType));

      // loops through the map
      @each $itemKey, $itemValue in $values {
        // to validate type of each item key and item value
        $result: validate(type-of($itemKey) == $genericKeyType, $errorMessage, $continue);
        // and to validate type of each item value.
        $result: validate(type-of($itemValue) == $genericValueType, $errorMessage, $continue);
      }
    }
  }
  @else {
    $result: validate(type-of($value) == $expectedType, $errorMessage, $continue);
  }

  @return $result;

}

// == String group ==

/// <reference path="./string/_str-contains.function.scss" />
/// <reference path="./string/_str-ends-with.function.scss" />
/// <reference path="./string/_str-replace.function.scss" />
/// <reference path="./string/_str-split.function.scss" />


// =============
// Group content
// =============

// Functions
// =========

/// Searches a substring at the end of a string.
/// @access public
/// @group common
/// @param {String} $string - The parent string
/// @param {String} $search - The substring to search
/// @return {Boolean} - True if the parent string ends with the substring
@function str-ends-with(
  $string,
  $search
  ) {
  $this: 'str-ends-with()';
  @if no-error(
    validate-type($string, 'string', argument-type-error('$string', $this, 'string')),
    validate-type($search, 'string', argument-type-error('$search', $this, 'string'))
    ) {



    // If the strings are equals
    @if $string == $search {
      // the parent string ends with the searched string.
      @return true;
    }

    $searchLength: str-length($search);
    $stringLength: str-length($string);

    // If the searched string is longer than the parent string
    @if $searchLength > $stringLength {
      // the parent string doesn't ends with the searched string.
      @return false;
    }
   
    // Gets the part of the parent string that we want to compare.
    $endToCompare: str-slice($string, $stringLength - $searchLength + 1);

    @return $endToCompare == $search;

  }
}
/// Searches a substring in a string.
/// @access public
/// @group common
/// @param {String} $string - The main string
/// @param {String} $search - The substring to search
/// @return {Boolean} - True if the main string contains the substring
@function str-contains(
  $string,
  $search
  ) {
  @if no-error(
    validate-type($string, 'string', argument-type-error('$string', 'str-contains()', 'string')),
    validate-type($search, 'string', argument-type-error('$search', 'str-contains()', 'string'))
    ) {


    @return str-index($string, $search) != null;
    
  }
}
/// Replaces a part of a character string with a given value.
/// @access public
/// @group common
/// @param {String} $string - The initial string
/// @param {String} $search - The substring to replace
/// @param {String} $replace - The replacement substring
/// @return {String} - The updated string
@function str-replace(
  $string,
  $search,
  $replace
  ) {
  @if no-error(
    validate-type($string, 'string', argument-type-error('$string', 'str-replace()', 'string')),
    validate-type($search, 'string', argument-type-error('$search', 'str-replace()', 'string')),
    validate($search != '', argument-value-error('$search', 'str-replace()', 'an empty string')),  
    validate-type($replace, 'string', argument-type-error('$replace', 'str-replace()', 'string'))
    ) {


    // Try to finds the position in the initial string of the first characters of the fist occurence of the string to replace.
    $searchStart: str-index($string, $search);
    
    // If an occurence of the search string is find.     
    @if $searchStart {
      // Gets the position in the initial string of the last characters of the fist occurence of the string to replace.
      $searchEnd: $searchStart + str-length($search);

      // Gets the characters that are before the string to replace.
      $partBefore: str-slice($string, 1, $searchStart - 1);

      // Gets the characters that are after the string to replace.
      $partAfter: str-slice($string, $searchEnd);

      // Replaces all other occurrences of the search string and return the new string.
      @return $partBefore + $replace + str-replace($partAfter, $search, $replace);
    }
    
    @return $string;
    
  }
}
/// Split a string into an list of substrings.
/// @access public
/// @group common
/// @param {String} $string - The string to split
/// @param {String} $delimiter [''] - The string that separate each substrings
/// @return {List} - The list of substrings
@function str-split(
  $string,
  $delimiter: ''
  ) {
  $this: 'str-split()';
  @if no-error(
    validate-type($string, 'string', argument-type-error('$string', $this)),
    validate($string != '', argument-value-error('$string', $this, '\'\'')),
    validate-type($delimiter, 'string', argument-type-error('$delimiter', $this))
    ) {

   
    // TODO(maximegelinas): Add comments.

    $result: ();
    $length: str-length($string);

    @if str-length($delimiter) == 0 {
      @for $i from 1 through $length {
        $result: append($result, str-slice($string, $i, $i));
      }
  
      @return $result;
    }

    $running: true;
    $remaining: $string;

    @while $running {
      $index: str-index($remaining, $delimiter);

      @if $index {
        $slice: str-slice($remaining, 1, $index - 1);
        $result: append($result, $slice);
        $remaining: str-slice($remaining, $index + str-length($delimiter));
      } 
      @else {
        $running: false;
      }
    }

    @return append($result, $remaining);

  }
}

// == List group ==

/// <reference path="./list/_first.function.scss" />
/// <reference path="./list/_prepend.function.scss" />
/// <reference path="./list/_remove-nth.function.scss" />
/// <reference path="./list/_remove-first.function.scss" />
/// <reference path="./list/_contains.function.scss" />


// =============
// Group content
// =============

// Functions
// =========

/// Returns the first element of a list.
/// @access public
/// @group common
/// @param {List} $list - The list containing the element
/// @return {*} - The first element of the given list
@function first(
  $list
  ) {
  @if no-error(
    validate-type($list, 'list', argument-type-error('$list', 'first()'))
    ) {


    @return nth($list, 1);

  }
}
/// Adds a new value at the beginning of a list.
/// @access public
/// @group common
/// @param {List} $list - The list that we want to expand
/// @param {*} $value - The value to add in the list
/// @return {List} - The new expanded list
@function prepend(
  $list, 
  $value
  ) {
  @if no-error(
    validate-type($list, 'list', argument-type-error('$list', 'prepend()'))
    ) {


    @return join($value, $list);

  }
}
/// Removes a element at a specific index in a list.
/// @access public
/// @group common
/// @param {List} $list - The list that we want to shrink
/// @param {Number} $index - The index of the element that we want to remove (can be negative to start from the end of the list)
/// @return {List} - The new shrinked list
@function remove-nth(
  $list,
  $index
  ) {
  @if no-error(
    validate-type($list, 'list', argument-type-error('$list', 'remove-nth()')),
    validate-type($index, 'number', argument-type-error('$index', 'remove-nth()')),
    validate($index != 0, argument-value-error('$index', 'remove-nth()', 0)),
    validate(abs($index) <= length($list), 'second argument `$index` of `remove-nth()` is #{$index} but the first argument `$list` is only #{length($list)} item long')
    ) {


    $result: ();
  
    // Calculates the element index if the index is negative.
    $index: if($index < 0, length($list) + $index + 1, $index);  
  
    @for $i from 1 through length($list) {
      // If the index is not the index that we want to remove,
      @if $i != $index {
        // adds the element at this index to the result.
        $result: append($result, nth($list, $i));
        }
      }
          
    @return $result;

    }
}
/// Removes a value at the beginning of a list.
/// @access public
/// @group common
/// @param {List} $list - The list that we want to shrink
/// @return {List} - The new shrinked list
@function remove-first(
  $list
) {
  @if no-error(
    validate-type($list, 'list', argument-type-error('$list', 'remove-first()'))
    ) {


    @return remove-nth($list, 1);

  }
}
/// Checks if a value is contained in a list.
/// @access public
/// @group common
/// @param {List} $list - The list to inspect
/// @param {*} $value - The value to find
/// @return {Boolean} - True if the value is found
@function contains(
  $list,
  $value
  ) {
  $this: 'contains()';
  @if no-error(
    validate-type($list, 'list', argument-type-error('$list', $this))
    ) {


    @return index($list, $value) != null;

  }
}



// == Map group ==

/// <reference path="./map/_map-deep-get.function.scss" />


// =============
// Group content
// =============

// Functions
// =========

/// Returns a deeply nested value from a map.
/// @access public
/// @group common
/// @param {Map} $map - The map containing the value
/// @param {List} $keys - The keys chain to access the value
/// @return {*} - The nested value
@function map-deep-get(
  $map,
  $keys
  ) {
  $this: 'map-deep-get()';
  @if no-error(
    validate-type($map, 'map', argument-type-error('$map', $this)),
    validate-type($keys, 'list', argument-type-error('$keys', $this))
    ) {


    // TODO(maximegelinas): Add comments.

    @each $key in $keys {
      @if type-of($map) == 'map' and map-has-key($map, $key) {
        $map: map-get($map, $key);
      }
      @else {
        @return null;
      }
    }

    @return $map;

  }
}

// == Scope group ==

/// <reference path="./scope/_base.function.scss" />
/// <reference path="./scope/_get.function.scss" />
/// <reference path="./scope/_new-scope.mixin.scss" />
/// <reference path="./scope/_this.function.scss" />


// =============
// Group content
// =============

// Variables
// =========

/// The stack of every scopes variables from the newer to the oldest
/// @access private
/// @group common
/// @type List
$_scope-variables-stack: () !global;

// Functions
// =========

/// Returns a variable from the current scope.
/// @access public
/// @group common
/// @param {String} $variablePath - The path of the variable to get
/// @return {*} - The scope variable
@function get(
  $variablePath
  ) {
  $this: 'get()';
  @if no-error(
    validate-type($variablePath, 'string', argument-type-error('$variablePath', $this))
    ) {

    // If we are not in a scope or the scope contains no variable.
    @if $_scope-variables-stack == () {
      @return null;
    }
    @else {
      // Gets the variables of the current scope.
      $scopeVariables: first($_scope-variables-stack);
    
      // Returns the asked variable or null if it doesn't exist.
      @return map-deep-get($scopeVariables, str-split($variablePath, ':'));
    }

  }
}
/// Returns the object where we are.
/// @access public
/// @group common
/// @param {String} $variablePath [''] - The path of the variable to get
/// @return {*} - The object
@function this(
  $variablePath: ''
  ) {
  $this: 'this()';
  @if no-error(
    validate-type($variablePath, 'string', argument-type-error('$variablePath', $this))
    ) {


    @if $variablePath != '' {
      $variablePath: ':#{$variablePath}';
    }

    $object: get('_this#{$variablePath}');

    @if $object == null {
      @error '`#{$this}` function can\'t be used outside of an object';
    }

    @return $object;

  }
}
/// Returns the parent object.
/// @access public
/// @group common
/// @param {String} $variablePath [''] - The path of the variable to get
/// @return {*} - The object
@function base(
  $variablePath: ''
  ) {
  $this: 'base()';
  @if no-error(
    validate-type($variablePath, 'string', argument-type-error('$variablePath', $this))
    ) {


    @if $variablePath != '' {
      $variablePath: ':#{$variablePath}';
    }

    $parentObject: get('_base#{$variablePath}');

    @if $parentObject == null {
      @error '`#{$this}` function can\'t be used outside of a nested object';
    }

    @return $parentObject;

  }
}

// Mixins
// ======

//// Creates a scope to store variables without affecting to global scope.
/// @access public
/// @group common
/// @param {string} $variables - The variables to store in the new scope
@mixin new-scope(
  $variables
  ) {
  @if no-error(
    validate-type($variables, 'map', argument-type-error('$variables', 'new-scope()'))
    ) {


    // Adds the variables to the scope.
    $_scope-variables-stack: prepend($_scope-variables-stack, $variables) !global;
  
    // Processes the scope execution.
    @content;
  
    // Removes the variables from the scope.
    $_scope-variables-stack: remove-first($_scope-variables-stack) !global;   

  } 
}

// =============
// Group content
// =============

// Groups
// ======

// == Component group ==

/// <reference path="./component/_component.mixin.scss" />
/// <reference path="./component/_dynamic.mixin.scss" />
/// <reference path="./component/_new-component.mixin.scss" />
/// <reference path="./component/_static.mixin.scss" />
/// <reference path="./component/_variant.scss" />


// =============
// Group content
// =============

// Variables
// =========

/// The list of every components
/// @access private
/// @group core
/// @type Map
$_components: () !global;

// Functions
// =========

/// Returns a component with a given name.
/// @access private
/// @group core
/// @param {String} $name - The component name
/// @return {Map} - The component
@function _get-component(
  $name
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', '_get-component()'))
    ) {


    $component: map-get($_components, $name);

    // If the component doesn't exists.
    @if ($component == null) {
      $component: ();
    }

    @return $component;

  }
}

/// Adds a new component.
/// @access private
/// @group core
/// @param {String} $name - The component name
/// @param {String} $selector [''] - Component CSS selector
/// @param {Map} $declarations [(null:null)] - A set of component property names and values like so `background: red` or `draggable: false`
/// @return {Map} - The edited component
@function _set-component(
  $name, 
  $selector: '', 
  $declarations: (null: null)
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', '_set-component()')),
    validate-type($selector, 'string', argument-type-error('$selector', '_set-component()')),
    validate-type($declarations, 'map', argument-type-error('$declarations', '_set-component()'))
    ) {

    // Initialises the new component map.
    $newComponent: ();

    @if ($selector != '') {
      $newComponent: map-merge($newComponent, (selector: $selector));
    }

    @if ($declarations != (null: null)) {
      $newComponent: map-merge($newComponent, (declarations: $declarations));
    }

    // Merges the new component with the existing one.
    $mergedComponent: map-merge(_get-component($name), $newComponent);

    // Replaces the overriden component to the list or adds it if it doesn't exist.
    $_components: map-merge($_components, ($name: $mergedComponent)) !global;

    @return $mergedComponent;

  }
}

// Mixins
// ======

/// Creates a new component scope.
/// @access public
/// @group core
/// @param {String} $name - The component name
/// @param {Map} $declarations [(null:null)] - The declarations for the default variant
@mixin component(
  $name,
  $declarations: (null: null)
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', 'component()')),
    validate-type($declarations, 'map', argument-type-error('$declarations', 'component()'))
    ) {

  
  
    // Makes sure that the component is created.
    $component: _set-component($name);

    // If we retrieve some declarations
    @if $declarations != (null: null) {
      // sets the default variant with these.
      $newVariant: _set-component-variant($name, 'default', '', $declarations);
    }
    @else {
      $declarations: ();
    }
  
    // Makes the parameters accessible from the `base` function.
    @include new-scope(('_base': ('name': $name, 'declarations': $declarations))) {
      // Processes the scope content.
      @content;
    }

  }   
}
/// Creates a new component and outputs his CSS.
/// @access public
/// @group core
/// @param {String} $name - The component name
/// @param {String} $selector - The CSS selector of the component
/// @param {Map} $declarations - A set of component property names and values like so `background: red` or `draggable: false`
@mixin new-component(
  $name,
  $selector,
  $declarations
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', 'new-component()')),
    validate-type($selector, 'string', argument-type-error('$selector', 'new-component()')),
    validate-type($declarations, 'map', argument-type-error('$declarations', 'new-component()'))
    ) {


        
    // If the component already exists
    @if map-has-key(_get-component($name), 'selector') {
      // throw an error.
      @error 'component `#{$name}` can\'t be declared twice';
    }

    // Overrides the existing component and get the result.
    $component: _set-component($name, $selector, $declarations);

    // Makes the parameters accessible from the `this` function.
    @include new-scope(('_this': ('name': $name, 'selector': $selector, 'declarations': $declarations))) {
      #{$selector} {
        // Processes the scope content.
        @content;
      }
    }

  }
}
/// Outputs the private CSS of a component.
/// The output cannot be changed in the theme file.
/// @access public
/// @group core
/// @output The current component static style
@mixin static {
  & {
    // Outputs the CSS.
    @content;
  }
}

/// Outputs the private CSS of a component.
/// The output cannot be changed in the theme file.
/// @access public
/// @group core
/// @output The current component style and its variants 
@mixin dynamic {
  $componentName: this('name');

  $componentDeclarations: map-get(_get-component($componentName), 'declarations');

  // Gets the variant declarations.
  $componentVariants: _get-component-variants($componentName);

  @if $componentVariants == () {
    @include new-scope($componentDeclarations) {
      @content;
    }
  }
  @else {
    // Loops through the component variants.
    @each $variantName, $variant in $componentVariants {
      // Gets the current variant selector.
      $variantSelector: map-get($variant, 'selector');
  
      // Gets the current variant declarations.
      $variantDeclarations: map-get($variant, 'declarations');
       
      // Merges the default declarations with the variant declarations.
      $mergedDeclarations: map-merge($componentDeclarations, $variantDeclarations); 
      
      // Creates a new scope containing the appropriate declarations.
      @include new-scope(if($variantName == 'default', $mergedDeclarations, $variantDeclarations)) {
        &#{$variantSelector} {
          // Outputs the CSS for the current variant.
          @content;
        }
      }
    }
  }
}

// Groups
// ======

/// <reference path="./variant/_component-variant.mixin.scss" />


// ==============
// Group content
// ==============

// Functions
// =========

/// Returns every variants of a component.
/// @access private
/// @group core
/// @param {String} $componentName 
/// @return {Map} - The component variants
@function _get-component-variants(
  $componentName
  ) {
  @if no-error(
    validate-type($componentName, 'string', argument-type-error('$componentName', '_get-component-variants()'))
    ) {


    // Gets the component.
    $component: _get-component($componentName);
    
    // Gets the component variants.
    $componentVariants: map-get($component, 'variants');
    
    // If the component doesn't has variants.
    @if ($componentVariants == null) {
      $componentVariants: ();
    }

    @return $componentVariants;

  }
}
/// Returns a component's variant.
/// @access private
/// @group core
/// @param {String} $componentName - The component name
/// @param {String} $variantName - The variant name to get
/// @return {Map} - The component variant
@function _get-component-variant(
  $componentName,
  $variantName
  ) {
  @if no-error(
    validate-type($componentName, 'string', argument-type-error('$componentName', '_get-component-variant()')),
    validate-type($variantName, 'string', argument-type-error('$variantName', '_get-component-variant()'))
    ) {


    $variant: null;
    
    // Gets the component variants.
    $componentVariants: _get-component-variants($componentName);

    // If the component doesn't has variants
    @if ($componentVariants == ()) {
      $variant: ();
    }
    // If the component has variants
    @else {
      // Gets the variant by its name.
      $variant: map-get($componentVariants, $variantName);

      // If the variant doesn't exists
      @if ($variant == null) {
        $variant: ();
      }
    }

    @return $variant;

  }
}
/// Adds a variant to a given component.
/// @access private
/// @group core
/// @param {String} $componentName - The component name 
/// @param {String} $variantName - The variant name
/// @param {String} $variantSelector [''] - The CSS selector of the variant
/// @param {Map} $variantDeclarations [(null:null)] - A set of variant property names and values like so `background: red` or `draggable: false`
/// @return {Map} - The edited component variant
@function _set-component-variant(
  $componentName,
  $variantName,
  $variantSelector: '',
  $variantDeclarations: (null: null)
  ) {
  @if no-error(
    validate-type($componentName, 'string', argument-type-error('$componentName', '_set-component-variant()')),
    validate-type($variantName, 'string', argument-type-error('$variantName', '_set-component-variant()')),
    validate-type($variantSelector, 'string', argument-type-error('$variantSelector', '_set-component-variant()')),
    validate-type($variantDeclarations, 'map', argument-type-error('$variantDeclarations', '_set-component-variant()'))
    ) {


    @if ($variantDeclarations == (null: null)) {
      $variantDeclarations: ();
    }

    // Gets the component variants.
    $componentVariants: _get-component-variants($componentName);

    // Creates the new variant map.
    $newVariant: (
      selector: $variantSelector,
      declarations: $variantDeclarations
    );

    // Merges the new component variant with the existing one.
    $mergedVariant: map-merge($componentVariants, ($variantName: $newVariant));

    // Adds the new variant to the component.
    $componentWithNewVariant: map-merge(_get-component($componentName), (variants: $mergedVariant));

    // Overrides the existing component with the component that has the new variant.
    $_components: map-merge($_components, ($componentName: $componentWithNewVariant)) !global;

    @return $newVariant;

  }
}

// Mixins
// ======

/// Creates a new component variant.
/// @access public
/// @group core
/// @param {String} $name - The variant name 
/// @param {String} $selector [''] - The CSS selector of the variant
/// @param {Map} $declarations [(null:null)] - A set of variant property names and values like so `background: red` or `draggable: false`
@mixin component-variant(
  $name,
  $selector,
  $declarations
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', 'component-variant()')),
    validate-type($selector, 'string', argument-type-error('$selector', 'component-variant()')),
    validate-type($declarations, 'map', argument-type-error('$declarations', 'component-variant()'))
    ) {


    $componentName: base('name');

    // If the variant already exists
    @if _get-component-variant($componentName, $name) != () {
      // throw an error.
      @error 'variant `#{$name}` of component `#{$componentName}` can\'t be declared twice';
    }

    $newVariant: _set-component-variant($componentName, $name, $selector, $declarations);

  }
}

// == Color group ==

/// <reference path="./color/_color-variant.mixin.scss" />
/// <reference path="./color/_color.mixin.scss" />
/// <reference path="./color/_get-color.function.scss" />


// =============
// Group content
// =============

// Variables
// =========

/// The list of every colors listed in the theme file
/// @access private
/// @group core
/// @type Map
$_colors: () !global;

// Functions
// =========

/// Returns an existing color.
/// @access public
/// @group core
/// @param {String} $name - The color name
/// @param {String} $variant - The name of the color variant
/// @return {Color} - The color code
@function get-color(
  $name,
  $variant: 'base'
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', 'get-color()')),
    validate-type($variant, 'string', argument-type-error('$variant', 'get-color()'))
    ) {


    // Gets the colors map.
    $color: map-get($_colors, $name);

    // Gets the color code.
    $color: if($color != null, map-get($color, $variant), null);

    @return $color;

  }
}

// Mixins
// ======

/// Adds a new color.
/// @access public
/// @group core
/// @param {String} $name - The color name
/// @param {Color} $code - The default color code
@mixin color(
  $name,
  $code
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', 'color()')),
    validate-type($code, 'color', argument-type-error('$code', 'color()'))
    ) {
    

      
    // If the color already exists
    @if map-has-key($_colors, $name) {
      // throw an error.
      @error 'color `#{$name}` can\'t be declared twice';     
    }

    // Creates the new color map with some default variants.
    $newColor: (
      'base': $code
    );

    // Adds the new color to the color list.
    $_colors: map-merge($_colors, ($name: $newColor)) !global;

    // Makes the parameters accessible from the `base` function.
    @include new-scope(('_base': ('name': $name, 'code': $code))) {
      @content;
    }

  }
}
/// Adds a new color variant.
/// @access public
/// @group core
/// @param {String} $name - The color variant name
/// @param {Color} $code - The color code
@mixin color-variant(
  $name,
  $code
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', 'color-variant()')),
    validate-type($code, 'color', argument-type-error('$code', 'color-variant()'))
    ) {


    // Gets the base color name from the scope.
    $baseColorName: base('name');
    // Gets the base color code.
    $baseColor: map-get($_colors, $baseColorName);

    // If the base color doesn't exists
    @if $baseColor == null {
      // throw an error.
      @error 'can\'t add variant `#{$name}` to an undefined color';
    }

    // If the color variant already exists
    @if get-color($baseColorName, $name) != null {
      // throw an error.
      @error 'variant `#{$name}` of color `#{baseColorName}` can\'t be declared twice';
    }

    // Creates the new color variant map.
    $newColorVariant: (
      $name: $code
    );

    // Adds the new color variant to the base color.
    $mergedColorMap: map-merge($baseColor, $newColorVariant);

    // Adds the edited color to the color list.
    $_colors: map-merge($_colors, ($baseColorName: $mergedColorMap)) !global;

  }
}

// == Font group ==

/// <reference path="./font/_font.mixin.scss" />
/// <reference path="./font/_get-font.function.scss" />


// =============
// Group content
// =============

// Variables
// =========

/// The list of every fonts listed in the theme file
/// @access private
/// @group core
/// @type Map
$_fonts: () !global;

// Functions
// =========

/// Returns an existing font.
/// @access public
/// @group core
/// @param {String} $name - The font name
/// @return {String} - The font family name
@function get-font(
  $name
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', 'get-font()'))
    ) {


    @return #{map-get($_fonts, $name)};

  }
}

// Mixins
// ======

/// Adds a new font.
/// @access public
/// @group core
/// @param {String} $name - The font name
/// @param {String} $family - The `font-family` property
/// @param {String} $style ['normal'] - The `font-style` property
/// @param {String} $weight ['normal'] - The `font-weight` property
@mixin font(
  $name,
  $family,
  $style: 'normal',
  $weight: 'normal'
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', 'font()')),
    validate-type($family, 'string', argument-type-error('$family', 'font()'))
    ) {


    $newFont: '#{$style} #{$weight} medium/normal #{$family}';

    // Adds the new font to the font list.
    $_fonts: map-merge($_fonts, ($name: $newFont)) !global;

  }
}

// == Media group ==

/// <reference path="./media/_media-response.mixin.scss" />
/// <reference path="./media/_media.mixin.scss" />


// =============
// Group content
// =============

// Variables
// =========

/// The list of every medias listed in the theme file
/// @access private
/// @group core
/// @type Map
$_medias: () !global;

// Mixins
// ======

/// Adds a new media.
/// @access public
/// @group core
/// @param {String} $name - The media name
/// @param {String} $query - The media query
@mixin media(
  $name,
  $query
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', 'media()')),
    validate-type($query, 'string', argument-type-error('$query', 'media()'))
    ) {


    // Adds the new media to the media list.
    $_medias: map-merge($_medias, ($name: $query)) !global;

  }
}
/// Returns an existing media.
/// @access public
/// @group core
/// @param {String} $name - The media query name
@mixin media-response(
  $name
  ) {
  @if no-error(
    validate-type($name, 'string', argument-type-error('$name', 'media-response()'))
    ) {


    @media #{map-get($_medias, $name)} {
      @content;
    }

  }
}